:toc2:

Level modification notes
------------------------

*This is not a guide how to make a level but rather an analysis/edit of an existing level, most about the levels is still unknown by me*

These are notes/research from modifying the `container1` level, the end result can be seen https://www.youtube.com/watch?v=L5SP9EPGs2o[here].

Start
~~~~~

Since we don't know a lot about the level files we will be taking `container1` as base, this is a simple level with 2 instances (3 intros including player intro).

To prevent having to pack the entire game bigfile.0xx everytime a little https://github.com/TheIndra55/TRAE-menu-hook/commit/0dc3545312f9bc6eb84b757835e48d6a8e85df5b[patch] has been written in my other project TRAE-menu-hook, this patch will load any units prefixed by 'fi' with the 'g_pDiskFS' filesystem which will load them from disk instead of the bigfile. Now when the game is installed on E:\ it will load from E:\units\fiTest.drm.

I will be using https://github.com/Gh0stBlade/cdcEngineTools[cdcEngineTools] by Gh0stBlade, these are awesome tools to unpack the drm sections to seperate files. We unpack container1.drm and get a bunch of files.

For container1 0_0.gnc is the file with the level struct and 1_0.gnc is the script file.

Level
~~~~~

The 0_0.gnc file contains the Level struct which has a lot of info about the level, I'm still not sure where it starts or how to find the offset to it but the easiest way now is to look for versionNumber. In the game load code you will see the following bytecode.
[source,cpp]
----
// generated by IDA decompiler
versionNumber = *((_DWORD *)level + 42);
if ( versionNumber != 79824059 )
	MAIN_FailAbort("Wrong version number (%X) for unit %s, code is at version %x.\n", v2, a1 + 12, 79824059);
----

Search for this `79824059` in the binary with your hex editor and you will be at offset 42 of the Level struct. I used the following pattern language together with https://github.com/WerWolv/ImHex[ImHex], these values are based on trae.pdb/tr7.pdb.
[source,cpp]
----
struct Level
{
	u32 numIntros;
	IntroList* introList: u32;
	ObjNameList* objectNameList: u32;
	String* worldName : u32;
	u32 startGoingIntoWaterSignal;
	u32 startGoingOutOfWaterSignal;
	u32 unitFlags;
	u32 SignalListStart;
	u32 SignalIDList;
	u32 splineCameraData;
	u32 relocModule;
	u32 NumberOfSFXMarkers;
	u32 SFXMarkerList;
	u32 versionNumber;
	u32 guiID;
	u32 dynamicMusicName;
	u32 streamUnitID;
};
----

For the entire pattern with IntroList and ObjNameList* please see this https://gist.github.com/TheIndra55/7a3cb3e0fd7448db721dcc8219e0fc6d[gist].

Instances
~~~~~~~~~

Instances in a level e.g. the doors, levers, enemies are defined as Intros these intros contain the position, rotation, scale, objectId and introId. The intro id is the uniqueId to find the intro, this can be used to e.g. find from a script the lever to query the status.

In the struct above you will see `introList` this is a points to an address in the file (with some unknown offset) where the IntroList is located. Loop trough numIntros with the following struct and you will get all intros.
[source,cpp]
----
struct Intro // taken from trae.pdb
{
	Vector rotation;
	Vector position;
	Vector dummy1; // unknown
	Vector dummy2; // unknown
	Vector scale;
	u16 objectID; // this is the id of the object, see default\trae\pc-w\objectlist.txt for all objects and their id
	u16 intronum; // unknown
	u32 UniqueID; // this is the unique intro id used by scripts
	u32 maxRad; // unknown
	u32 introFlags;
	u32 attachedVMO; // unknown
	u32 data;
	u32 multiSpline;
	u16 startFrame;
	u16 endFrame;
};
----

In container1 these will be autorifle_rbweapon and the shotgun, we can replace these with our own objects for this example to demonstrate the script I will replace them with `dr_pu__batcave_slidingdoor` and `sw_gr_floorswitch`. Find the object ids and replace the hex with them. You can change the unique id too if you like for example to 3237.

When we repack the file and load into our unit we will for suprise see no instances, multiple hours later I stumble upon some code which sets the intro flag to 33554432. Intros with this flag will not be "introduced" thus not spawn. This flag is set if the object is not in the game's GlobalObjects array. This is where the `objectNameList` member joins in.

The objectNameList list contains all object ids to insert in the GlobalObjects array, the list has no length and will read until it reads nul. Adding our own object ids in this list and loading the unit again will load instances.

image:images/intros.png[width=500]

Script
~~~~~~

Read https://theindra.eu/projects/TRAE-Research/research.html#_scripts[scripts] for info about scripts

Scripts are written in C/C++ and then compiled to a dll file, add to functions to your code `EventMain` and `EventRelocate`.

[source,cpp]
----
extern "C" int EventMain(int a1, int a2, int a3)
{
	// called every loop

	return a3;
}
extern "C" int EventRelocate()
{
	return 0;
}
----

This script has no entry point and therefore has to be compiled without CRT, open the 'x86 Native Tools Command Prompt for VS' and build your code with the following compiler/linker options.
[source,bash]
----
cl script.cpp /LD /link /OUT:container1.dll /NOENTRY /NODEFAULTLIB /SUBSYSTEM:WINDOWS /NOCOFFGRPINFO /FILEALIGN:4096 /DYNAMICBASE:no /NXCOMPAT:no /SAFESEH:no /EXPORT:EventMain /EXPORT:EventRelocate
----

open the old script (1_0.gnc for container1) with your favorite hex editor and copy the SECT header from cdcEngineTools (24 bytes) and keep it somewhere, now replace the script with your dll and append the old SECT header in front of it.

[source,hexdump]
----
00000000  53 45 43 54 00 40 00 00 00 00 00 00 00 00 00 00  SECT.@..........
00000010  00 00 00 00 FF FF FF FF 4D 5A                    ....每每每每MZ
----

The first 4 bytes is the SECT magic, the next 4 bytes is the length of the section data. Take the length of your dll without the SECT header and write it at those 4 bytes, for me this was always 0x4000 because of the FILEALIGN. The last 2 bytes in this hexdump is the MZ magic from your dll this is the section data and thuss the script.

Loading the script unit now will give an error from game reloc 'Error relocating module code -1' this is due the game checking all sections, if one section has a larger virtual size than raw size it will return -1. Easiest solution open the file in https://ntcore.com/?page_id=388[CFF Explorer] and edit from any empty sections the virtual size from 00000001 to 00000000.

image:images/sections.png[]

Repeat the same steps above and now the game will load the unit fine.

Now we can write a little script as demonstration we wil use the following code
[source,cpp]
----
bool done = false; // waaa global variables

extern "C" int EventMain(int a1, int a2, int a3)
{
	auto instanceFind = ((int(__cdecl*)(int)) * (int*)(a3 + 252));
	auto instanceQuery = ((int(__cdecl*)(int, int)) * (int*)(a3 + 236));
	auto instancePost = ((void(__cdecl*)(int, int, int)) * (int*)(a3 + 240));

	int lever = instanceFind(4); // find the instance by intro id 4 (our lever)
	if (lever) // if instance exist
	{
		if (!done && instanceQuery(lever, 233) == 1) // query the lever until it becomes 1
		{
			// at 528 there is a nullsub located, this function was used by game as debug prints.
			// in TRAE-menu-hook this function is patched so you can read orginal level debug and your own.
			(*(void (__cdecl **)(const char *, signed int))(a3 + 528))("print from script", 60);
			
			int door = instanceFind(3237); // find the door by the intro we gave it
			instancePost(door, 8388753, 1); // post the door to open
			done = true;
		}
	}

	return a3;
}

// don't forget your EventRelocate this exported function is required
----

Compile the script and follow the instructions above, now load the level and while pulling the lever the door will open!